flink 提交作业和执行任务关键组件
    client 代码由客户端获取做转换之后提交给jobManager
    JobManager就是flink集群里面的管事人，对作业进行中央调度管理，获取到作业然后转换，分发给taskManager
    TaskManager 就是真正干活的人，数据的处理操作都是由他完成的

在flink-conf.yaml文件中还可以对集群中的JobManager和TaskManager组件进行优化配置，
    主要配置项如下：
    jobmanager.memory.process.size：
        对JobManager进程可使用到的全部内存进行配置，包括JVM元空间和其他开销，默认为1600M，可以根据集群规模进行适当调整。
    taskmanager.memory.process.size：
        对TaskManager进程可使用到的全部内存进行配置，包括JVM元空间和其他开销，默认为1728M，可以根据集群规模进行适当调整。
    taskmanager.numberOfTaskSlots：
        对每个TaskManager能够分配的Slot数量进行配置，默认为1，可根据TaskManager所在的机器能够提供给Flink的CPU数量决定。
        所谓Slot就是TaskManager中具体运行一个任务所分配的计算资源。
    parallelism.default：Flink任务执行的并行度，默认为1。优先级低于代码中进行的并行度配置和任务提交时使用参数指定的并行度数量。


flink 部署模式 （抽象）
    生命周期/资源的分配方式 main在那里执行client还是JobManager

    会话模式
        符合常规思维，先启动一个集群，保持一个会话，通过客户端提交作业，启动时候作业的所有资源已经确定了，所有提交的作业会竞争资源
        单个规模小，执行时间短的大量作业
    单作业模式
        会话模式共享资源出现问题，为了更好的隔离资源，每个提交的作业启动一个集群，这就是所谓的单作业模式
        作业完成集群关闭资源释放
        资源问题，实际应用的首选模式，本身无法直接运行，需要借助外部资源调度工具，yarn k8s
    应用模式
        以上两个都是在客户端执行然后交给JobManager,需要占用大量的网络带宽，加重客户端所有节点的资源消耗 ，我们不要客户端，直接在
        JObManager上运行，我们为每个提交的应用程序启动一个TaskManager,就是创建一个集群，只为了这个应用而存在，执行结束就关闭
        这就是应用模式
        后面2个模式都是提交了作业才创建集群， 单作业是通过客户端来提交，客户端解析出的每个作业对应一个集群，而应用模式下，是直接由JobManager执行
flink 部署模式（具体）


