flink的时间语义
    事件时间：
        数据产生的时间时间戳
    处理时间
        数据真正被处理的时间


    数据处理系统中的时间语义
    在实际应用中，事件时间语义会更为常见。一般情况下，业务日志数据中都会记录数据生成的时间戳（timestamp），它就可以作为事件时间的判断基础。
    在Flink中，由于处理时间比较简单，早期版本默认的时间语义是处理时间；而考虑到事件时间在实际应用中更为广泛，从Flink1.12版本开始，Flink已经将事件时间作为默认的时间语义了。

    水位线（Watermark）
    在Flink中，用来衡量事件时间进展的标记，就被称作“水位线”（Watermark）。
    具体实现上，水位线可以看作一条特殊的数据记录，它是插入到数据流中的一个标记点，主要内容就是一个时间戳，
    用来指示当前的事件时间。而它插入流中的位置，就应该是在某个数据到来之后；这样就可以从这个数据中提取时间戳，作为当前水位线的时间戳了。

    有序流中的水位线
    理想状态下，数据应该按照生成先后顺序进入流中，每条数据产生一个水位线
    实际中，数据量非常大，同时涌进来的数据时间差非常小，所以未来提高效率，一般会每隔一段时间产生一个水位线

    乱序流中的水位线
    由于网络延迟，导致数据出现乱序，

    乱序+数据量小:我们还是靠数据来驱动，每来一个数据就提取它的时间戳、插入一个水位线。不过现在的情况是数据乱序，所以插入新的水位线时，要先判断一下时间戳是否比之前的大，
    否则就不再生成新的水位线。也就是说，只有数据的时间戳比当前时钟大，才能推动时钟前进，这时才插入水位线。

    乱序 + 数据量大:如果考虑到大量数据同时到来的处理效率，我们同样可以周期性地生成水位线。这时只需要保存一下之前所有数据中的最大时间戳，需要插入水位线时，就直接以它作为时间戳生成新的水位线。

    乱序 + 迟到数据:我们无法正确处理“迟到”的数据。为了让窗口能够正确收集到迟到的数据，我们也可以等上一段时间，比如2秒，
    也就是用当前已有数据的最大时间戳减去2秒，就是要插入的水位线的时间戳。这样的话，9秒的数据到来之后，事件时钟不会直接推进到9秒，而是进展到了7秒;
    必须等到11秒的数据到来之后，事件时钟才会进展到9秒，这时迟到数据也都已收集齐，0~9秒的窗口就可以正确计算结果了。

    现在我们可以知道，水位线就代表了当前的事件时间时钟，而且可以在数据的时间戳基础上加一些延迟来保证不丢数据，这一点对于乱序流的正确处理非常重要。


    水位线是插入到数据流中的一个标记，可以认为是一个特殊的数据水位线主要的内容是一个时间戳，用来表示当前事件时间的进展
    水位线是基于数据的时间戳生成的
    水位线的时间戳必须单调递增，以确保任务的事件时间时钟一直向前推进水位线可以通过设置延迟，来保证正确处理乱序数据
    个水位线Watermark(t)，表示在当前流中事件时间已经达到了时间戳t，这代表t之前的所有数据都到齐了，之后流中不会出现时间戳t <= t的数据
    水位线是Flink流处理中保证结果正确性的核心机制，它往往会跟窗口一起配合，完成对乱序数据的正确处理。

    误解:在Flink
    中，窗口就是用来处理无界流的核心。我们很容易把窗口想象成一个固定位置的“框”，数据源源不断地流过来，到某个时间点窗口该关闭了，就停止收集数据、触发计算并输出结果。
    例如，我们定义一个时间窗口，每10秒统计一次数据，那么就相当于把窗口放在那里，从0秒开始收集数据，到10秒时，处理当前窗口内所有数据，输出一个结果，然后清空窗口继续收集数据，
    到20秒时，再对窗口内所有数据进行计算处理，输出结果;依次类推。


    注意:为了明确数据划分到哪一个窗口，定义窗口都是包含起始时间、不包含结束时间的，用数学符号表示就是一个左闭右开的区间，例如0~10秒的窗口可以表示为[0，10)，这里单位为秒

    问题描述:对于处理时间下的窗口而言，这样理解似乎没什么问题。然而如果我们采用事件时间语义，就会有些费解了。由于有乱序数据，我们需要设置一个延迟时间来等所有数据到齐。
    比如上面的例子中，我们可以设置延迟时间为2秒，这样010秒的窗口会在时间戳为12的数据到来之后，才真下关闭计算输出结果，这样就可以下常句含迟到的9秒数据了。
    但是这样一来，0-10秒的窗口不光包含了迟到的9秒数据，连11秒和12秒的数据也包含进去了。我们为了正确处理迟到数据，结果把早到的数据划分到了错误的窗口一-最终结果都是错误的

    正确理解:在Flink中，窗口其实并不是一个“框”，应该把窗口理解成一个“桶在Flink中，
    窗口可以把流切割成有限大小的多个“存储桶(bucket);每个数据都会分发到对应的桶中，当到达窗口结束时间时，就对每个桶中收集的数据进行计算处理

    正确理解:在Flink中，窗口其实并不是一个“框”，应该把窗口理解成一个“桶在Flink中，窗口可以把流切割成有限大小的多个“存储桶(bucket);每个数据都会分发到对应的桶中，
    当到达窗口结束时间时，就对每个桶中收集的数据进行计算处理

    注意：Flink中窗口并不是静态准备好的，而是动态创建——当有落在这个窗口区间范围的数据达到时，才创建对应的窗口。
    另外，这里我们认为到达窗口结束时间时，窗口就触发计算并关闭，事实上“触发计算”和“窗口关闭”两个行为也可以分开，这部分内容我们会在后面详述。

    生成水位线的总体原则
    完美的水位线是“绝对正确”的，也就是一个水位线一旦出现，就表示这个时间之前的数据已经全部到齐、之后再也不会出现了。不过如果要保证绝对正确，
    就必须等足够长的时间，这会带来更高的延迟。
    如果我们希望处理得更快、实时性更强，那么可以将水位线延迟设得低一些。这种情况下，可能很多迟到数据会在水位线之后才到达，就会导致窗口遗漏数据，
    计算结果不准确。当然，如果我们对准确性完全不考虑、一味地追求处理速度，可以直接使用处理时间语义，这在理论上可以得到最低的延迟。
    所以Flink中的水位线，其实是流处理中对低延迟和结果正确性的一个权衡机制，而且把控制的权力交给了程序员，我们可以在代码中定义水位线的生成策略。

     水位线生成策略
    在Flink的DataStream API中，有一个单独用于生成水位线的方法：.assignTimestampsAndWatermarks()，它主要用来为流中的数据分配时间戳，并生成水位线来指示事件时间。具体使用如下：
    DataStream<Event> stream = env.addSource(new ClickSource());

    DataStream<Event> withTimestampsAndWatermarks =
    stream.assignTimestampsAndWatermarks(<watermark strategy>);
    说明：WatermarkStrategy作为参数，这就是所谓的“水位线生成策略”。WatermarkStrategy是一个接口，该接口中包含了一个“时间戳分配器”TimestampAssigner和一个“水位线生成器”WatermarkGenerator。
    public interface WatermarkStrategy<T>
        extends TimestampAssignerSupplier<T>,
                WatermarkGeneratorSupplier<T>{

        // 负责从流中数据元素的某个字段中提取时间戳，并分配给元素。时间戳的分配是生成水位线的基础。
        @Override
        TimestampAssigner<T> createTimestampAssigner(TimestampAssignerSupplier.Context context);

        // 主要负责按照既定的方式，基于时间戳生成水位线
        @Override
        WatermarkGenerator<T> createWatermarkGenerator(WatermarkGeneratorSupplier.Context context);
    }

     Flink内置水位线
    1）有序流中内置水位线设置
    对于有序流，主要特点就是时间戳单调增长，所以永远不会出现迟到数据的问题。这是周期性生成水位线的最简单的场景，直接调用WatermarkStrategy.forMonotonousTimestamps()方法就可以实现

    乱序流中内置水位线设置
    由于乱序流中需要等待迟到数据到齐，所以必须设置一个固定量的延迟时间。这时生成水位线的时间戳，就是当前数据流中最大的时间戳减去延迟的结果，
    相当于把表调慢，当前时钟会滞后于数据的最大时间戳。调用WatermarkStrategy. forBoundedOutOfOrderness()方法就可以实现。
    这个方法需要传入一个maxOutOfOrderness参数，表示“最大乱序程度”，它表示数据流中乱序数据时间戳的最大差值；如果我们能确定乱序程度，
    那么设置对应时间长度的延迟，就可以等到所有的乱序数据了。